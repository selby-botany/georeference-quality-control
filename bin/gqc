#!/bin/bash
#
#    Geolocation Quality Control (gqc)
#
#    Copyright (C) 2020 Marie Selby Botanical Gardens
#

set -o errexit
set -o errtrace
set -o functrace
set -o nounset
set -o pipefail

export GQC_DEBUG="${GQC_DEBUG:-false}"
GQC_DEBUG=$(echo "${GQC_DEBUG}" | tr A-Z a-z)
if [[ "${GQC_DEBUG}" == "true" ]]; then set -xv; fi
export GQC_DEV="${GQC_DEV:-false}"
GQC_DEV=$(echo "${GQC_DEV}" | tr A-Z a-z)
GQC_PID=$$

prg=${BASH_SOURCE[0]}
([[ -n "${prg}" ]] && [[ -f "${prg}" ]]) || (echo "[FATAL] cannot locate: '$0'" 1>&2; kill -USR2 $GQC_PID)
task=$(basename -- "$0")
taskdir=$(cd $(dirname -- "$0")/.. > /dev/null && pwd)


function gqcw.exit_0 () {
    kill -USR1 $GQC_PID
    exit 0
}

function gqcw.exit_1 () {
    kill -USR1 $GQC_PID
    exit 1
}

function gqcw.debug () {
    echo "[DEBUG] ${@}" 1>&2
}

function gqcw.dryrun () {
    echo "[DRYRUN] ${@}" 1>&2
}

function gqcw.fatal () {
    gqcw.fatal_no_exit "${@}" 1>&2
    gqcw.exit_1
}

function gqcw.fatal_no_exit () {
    echo "[FATAL] ${@}" 1>&2
}

function gqcw.info () {
    echo "[INFO] ${@}" 1>&2
}

function gqcw.get_ini() {
    local var=${1:?Need variable}
    local default=${1:-}

    local inifiles=("${HOME}/.gqc" "/usr/local/selby/include/gqc.init" "${taskdir}/gqc.init")
    local retval=${default}
    for inifile in "${inifiles[@]}"; do
        if [[ -r "${inifile}" ]]; then
            val=$(cat "${inifile}" | grep --text --extended-regexp -- "^${var}=" | tail -n 1 | cut -d= -f2- | sed "s/^\([\"']\)\(.*\)\1\$/\2/g")
            retval=${val:-${retval}}
        fi
    done
    echo $retval
}

function gqcw.main() {
    local cachedir="${taskdir}/cache"
    local logdir=
    local logfile=
    local Xdebug=${GQC_DEBUG}
    local Xdockerargs=
    local Xdockercmd="/usr/local/selby/bin/gqc"
    local Xdev=${GQC_DEV}
    local Xdryrun=false
    local Ximage=selbybotany/gqc:$(cd "${taskdir}" && git branch --show-current)
    local Xcontainer=$(echo "${Ximage}" | cut -d: -f1 | tr -d '[:space:]' | tr -c '[:alnum:]' '-')
    local Xmount=

    local otherargs=
    while [[ "${#}" -gt "0" ]]; do
        case ${1} in
        -C|--cache-directory)
            local file="${2}" && shift
            ([[ -d "${file}" ]] && [[ -w "${file}" ]]) || (gqcw.fatal "cache directory does not exist or can not be written: '${file}'")
            cachedir="${file}"
            ;;
        -L|--log-file)
            local file="${2}" && shift
            [[ -e "${file}" ]] || (touch -- "${file}" || gqcw.fatal "log file can not be written: '${file}'")
            [[ -w "${file}" ]] || (gqcw.fatal "log file can not be written: '${file}'")
            logfile="${file}"
            ;;
        --Xcontainer-name)
            Xcontainer="${2}" && shift
            ;;
        --Xdebug)
            set -xv
            Xdebug=true
            GQC_DEBUG=true
            ;;
        --Xdev)
            Xdev=true
            GQC_DEV=true
            ;;
        --Xdockerargs)
            Xdockerargs="${Xdockerargs} ${2}" && shift
            ;;
        --Xdockercmd)
            Xdockercmd="${2}" && shift
            ;;
        --Xdryrun)
            Xdryrun=true
            ;;
        --Ximage)
            Ximage="${2}" && shift
            Xcontainer=$(echo "${Ximage}" | cut -d: -f1 | tr -d '[:space:]' | tr -c '[:alnum:]' '-')
            ;;
        --Xmount)
            Xmount="${Xmount} --mount ${2}" && shift
            Xdev=true
            GQC_DEV=true
            ;;
        (*)
            otherargs="${otherargs} ${1}"
            ;;
        esac
        shift
    done

    local image=$(docker images | awk '{ printf("%s:%s\n",$1,$2) }' | grep -- "${Ximage}" | head -n 1 | awk '{ print $1 }')
    if [[ "${Xdev}" != "true" ]] && [[ -z "${image}" ]]; then
        # First try pulling it
        cd "${taskdir}"
        (
            gqcw.info "pulling image from github: '${Ximage}' ..." &&
            docker pull "${Ximage}" >/dev/null 2>&1 &&
            gqcw.info "image pulled from github: '${Ximage}'"
        ) || gqcw.info "image not found on github: '${Ximage}' ..."
    fi
    local image=$(docker images | awk '{ printf("%s:%s\n",$1,$2) }' | grep -- "${Ximage}" | head -n 1 | awk '{ print $1 }')
    if [[ -z "${image}" ]]; then
        cd "${taskdir}"
        local tmp="${TMPDIR}/${task}-${$}-${RANDOM}"
        gqcw.info "building image: '${Ximage}' ..."
        if ! (docker build --tag "${Ximage}" . >${tmp} 2>&1); then
            gqcw.fatal "image can not be built: '${Ximage}'"
            cat "${tmp}" | while read line ; do
                 gqcw.debug "${line}'"
             done
             gqcw.exit_1
         fi
        gqcw.info "image build complete: '${Ximage}' ..."
    fi

    local exports=
    local host=$(gqcw.get_ini LOCATIONIQ_API_HOST)
    [[ -n "${host}" ]] && exports="${exports} --env LOCATIONIQ_API_HOST=${host}"
    local token=$(gqcw.get_ini LOCATIONIQ_API_TOKEN)
    [[ -n "${token}" ]] && exports="${exports} --env LOCATIONIQ_API_TOKEN=${token}"

    local opts="--interactive --rm"
    [[ -n "${Xcontainer}" ]] && opts="${opts} --name ${Xcontainer}"
    opts="${opts} --env GQC_DEBUG=${GQC_DEBUG}"
    opts="${opts} --env GQC_DEV=${GQC_DEV}"
    [[ -n "${Xdockerargs}" ]] && opts="${opts} ${Xdockerargs}"
    [[ -n "${exports}" ]] && opts="${opts} ${exports}"
    opts="${opts} --sig-proxy"
    opts="${opts} --stop-signal SIGTERM"
    opts="${opts} --mount type=bind,src=${cachedir},dst=/var/cache/selby"
    if [[ -n "${logfile}" ]]; then
        local dir=$(cd $(dirname -- "${logfile}") > /dev/null && pwd)
        local file=$(basename -- "${logfile}")
        opts="${opts} --mount type=bind,src=${dir},dst=/var/log/selby"
        otherargs="--log-file /var/log/selby/${file} ${otherargs}"
    else
        opts="${opts} --mount type=bind,src=${taskdir}/log,dst=/var/log/selby"
    fi
    if [[ -n "${Xmount}" ]]; then
        opts="${opts} ${Xmount}"
    fi
    if [[ "${Xdebug}" == "true" ]]; then
       otherargs="--Xdebug ${otherargs}"
   fi
    if [[ "${Xdev}" == "true" ]]; then
        opts="${opts} --mount type=bind,src=${taskdir}/src,dst=/usr/local/selby"
        otherargs="--Xdev ${otherargs}"
    fi

    local cmd="docker run ${opts} ${Ximage} ${Xdockercmd} ${otherargs}"
    if [[ "${Xdryrun}" == "true" ]]; then
        gqcw.dryrun "GQC_DEBUG=${GQC_DEBUG} GQC_DEV=${GQC_DEV} ${cmd}" "${@}"
    else
        [[ "${Xdebug}" == "true" ]] && gqcw.debug "GQC_DEBUG=${GQC_DEBUG} GQC_DEV=${GQC_DEV} ${cmd}" "${@}"
        GQC_DEBUG=${GQC_DEBUG} GQC_DEV=${GQC_DEV} ${cmd} "${@}"
    fi
}

trap 'exit 0' USR1
trap 'exit 1' USR2
trap 's=$?; rm -rf ${TMPDIR}/${task}-${$}; exit $s' HUP INT TERM EXIT
(
    gqcw.main "$@"
)
trap - HUP INT TERM EXIT USR1 USR2
exit 0


