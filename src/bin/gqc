#!/bin/bash
#
#    Geolocation Quality Control (gqc)
#
#    Copyright (C) 2020 Marie Selby Botanical Gardens
#

set -o errexit
set -o errtrace
set -o functrace
set -o nounset
set -o pipefail

export GQC_DEBUG="${GQC_DEBUG:-false}"
GQC_DEBUG=$(echo "${GQC_DEBUG}" | tr '[:upper:]' '[:lower:]')
if [[ "${GQC_DEBUG}" == "true" ]]; then set -xv; fi
export GQC_DEV="${GQC_DEV:-false}"
GQC_DEV=$(echo "${GQC_DEV}" | tr '[:upper:]' '[:lower:]')
export GQC_PID=$$
export GQC_TMPDIR="${TMPDIR:-/tmp}"


(( ${BASH_VERSINFO:-0} < 4 )) && (echo "[FATAL] bash version 4 or greater is required" 1>&2; exit 1)

# Script configuration is held in this hash table
declare -A GQC
GQC[DEBUG]=${GQC_DEBUG}
GQC[DEV]=${GQC_DEV}
GQC[INPUT]=${GQC_INPUT:-/dev/stdin}
GQC[OUTPUT]=${GQC_OUTPUT:-/dev/stdout}
GQC[QUIET]=${GQC_QUIET:-false}
GQC[SEPARATOR]=${GQC[SEPARATOR]:-','}
# 5 digits is ~1 meter resolution
# 4 digits is ~10 meter resolution
# 3 digits is ~100 meter resolution
# 2 digits is ~1 kilometer resolution
# 1 digits is ~10 kilometer resolution
GQC[LATITUDE_PRECISION]=${GQC_LATITUDE_PRECISION:-3}
GQC[LONGITUDE_PRECISION]=${GQC_LONGITUDE_PRECISION:-3}

declare -A LOCATIONIQ
LOCATIONIQ[API_TOKEN]=${LOCATIONIQ_API_TOKEN:-}
LOCATIONIQ[API_HOST]=${LOCATIONIQ_API_HOST:-}

declare -A LOG
LOG[DEBUG]=5
LOG[INFO]=4
LOG[WARN]=3
LOG[ERROR]=2
LOG[FATAL]=1
LOG[QUIET]=0
LOG[LOGLEVEL]="${LOG[INFO]}"
LOG[REQUESTID]=
LOG[USE_TIMESTAMP]=false

function cache.__check_function() {
    local f=${1:-Need function}
    local func=${f#cache.}
    local retval=
    for f in $(declare -F | awk '{ print $3 }' | grep -E '^cache\.' | sed 's/^cache\.//'); do
        if [[ "${f}" = "${func}" ]]; then
            retval="${func}"
        fi
    done
    [[ -n "${retval}" ]] && echo "cache.${retval}"
}

function cache.__get() {
    local key="${1:?Need key}"
    local data_filename
    data_filename=$(cache.get-data-filename "${key}")
    [[ -r "${data_filename}" ]] && cat "${data_filename}"
}

function cache.__put() {
    local key="${1:?Need key}" && shift
    local data_filename meta_filename
    data_filename=$(cache.get-data-filename "${key}")
    meta_filename=$(cache.get-meta-filename "${key}")
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi > "${data_filename}"
}

function cache.__update-metadata() {
    local key="${1:?Need key}"
    local data_filename datetime id length sha1 sha256 user
    id=$(cache.key-to-id "${key}")
    data_filename=$(cache.get-data-filename "${key}")
    sha1=$(hash.sha1 <"${data_filename}" | awk '{print $1}')
    sha256=$(hash.sha256 <"${data_filename}" | awk '{print $1}')
    length=$(wc -c <"${data_filename}")
    datetime=$(date --utc "+%Y-%m-%dT%TZ")
    user=$(whoami)
    cache.__update-meta-key-value "${key}" "key" "${key}"
    cache.__update-meta-key-value "${key}" "id" "${id}"
    cache.__update-meta-key-value "${key}" "modified-at" "${datetime}"
    cache.__update-meta-key-value "${key}" "modified-by" "${user}"
    cache.__update-meta-key-value "${key}" "length" "${length}"
    cache.__update-meta-key-value "${key}" "sha1" "${sha1}"
    cache.__update-meta-key-value "${key}" "sha256" "${sha256}"
    true
}

function cache.__update-meta-key-value() {
    local key="${1:?Need  key}"
    local tag="${2:?Need meta tag}"
    local value="${3:-}"
    local meta_filename tmpfile
    meta_filename=$(cache.get-meta-filename "${key}")
    tmpfile=$(mktemp "${GQC[TASK]}-${GQC[REQUESTID]}-XXXXXXXX.meta.tmp")
    cache.get-metadata "${key}" | \
        jq --arg k "${tag}" 'del(.[$k])' | \
        jq --arg k "${tag}" --arg v "${value}" '.[$k] = $v' \
        > "${tmpfile}" && \
        mv "${tmpfile}" "${meta_filename}"
}

function cache.append() {
    local cache_key="${1:?Need key}"
    local cache_data_filename
    cache_data_filename=$(cache.get-data-filename "${cache_key}") && shift
    cache.__put "$@" >> "${cache_data_filename}"
    cache.__update-metadata "${cache_key}"
}

function cache.directory() {
    local result=${GQC[CACHEDIR]}
    # shellcheck disable=SC2174
    [[ -d "${result}" ]] || mkdir -m 755 -p "${result}"
    [[ -r "${result}" ]] || chmod 755 "${result}"
    echo "${result}"
}

function cache.exists() {
    local key="${1:?Need key}"
    local cache_data_filename=
    cache_data_filename=$(cache.get-data-filename "${key}")
    local cache_meta_filename=
    cache_meta_filename=$(cache.get-meta-filename "${key}")
    [[ -r "${cache_data_filename}" ]] && [[ -r "${cache_meta_filename}" ]] && \
    [[ -w "${cache_data_filename}" ]] && [[ -w "${cache_meta_filename}" ]]
}

function cache.get-data-filename() {
    local key="${1:?Need key}"
    local id
    id=$(cache.key-to-id "${key}")
    echo "$(cache.directory)/${id}.data"
}

function cache.get-meta-filename() {
    local key="${1:?Need key}"
    local id
    id=$(cache.key-to-id "${key}")
    echo "$(cache.directory)/${id}.meta"
}

function cache.get() {
    local key="${1:?Need key}"
    # shellcheck disable=SC2174
    cache.__get "${key}" || (local f; f=$(cache.get-data-filename "${key}"); log.error "Key «$key» data file '${f}' can not be read" 1>&2 ; exit 1)
}

function cache.get-metadata() {
    local key="${1:?Need key}"
    local meta_filename
    meta_filename=$(cache.get-meta-filename "${key}")
    ([[ -r "${meta_filename}" ]] && cat "${meta_filename}") || jq -n '{}'
}

function cache.get-with-default() {
    local key="${1:?Need key}"
    cache.__get "${key}" || jq -n '{}'
}

function cache.key-to-id() {
    local key=${1:?Need key}
    echo "${key}"
}

function cache.put() {
    local key="${1:?Need key}"
    local data_filename
    data_filename=$(cache.get-data-filename "${key}")
    cache.__put "$@" > "${data_filename}"
    cache.__update-metadata "${key}"
}

function hash.md5() {
    md5sum | awk '{print $1}'
}

function hash.sha1() {
    sha1sum | awk '{print $1}'
}

function hash.sha224() {
    sha224sum | awk '{print $1}'
}

function hash.sha256() {
    sha256sum | awk '{print $1}'
}

function hash.sha384() {
    sha384sum  | awk '{print $1}'
}

function hash.sha512() {
    sha512sum | awk '{print $1}'
}

function locationiq.reverse-geolocate() {
    local error latitude longitude result url
    latitude=$(text.trim "${1:?Need latitude}")
    longitude=$(text.trim "${2:?Need longitude}")
    url=$(locationiq.reverse-geolocate-url "${latitude}" "${longitude}")
    log.debug "reverse-geolocate: lat=${latitude} long=${longitude} url=${url}" > /dev/null
    result=$(curl --silent --get "${url}")
    error=$(echo "${result}" | jq .error)
    if [[ -n "${error}" ]] && [[ "${error}" != "null" ]]; then
       log.error "reverse geolocate request error: lat='${latitude}', lon='${longitude}' result='${result}' error='${error}'" > /dev/null
       result=
    fi
    echo "${result}"
}

function locationiq.reverse-geolocate-url() {
    local latitude longitude
    latitude=$(text.trim "${1:?Need latitude}")
    longitude=$(text.trim "${2:?Need longitude}")
    echo "https://${LOCATIONIQ[API_HOST]}/v1/reverse.php?key=${LOCATIONIQ[API_TOKEN]}&lat=${latitude}&lon=${longitude}&format=json"
}

function log.should-log() {
    local funcname="${1#log.}"
    local level="${funcname^^}"
    [[ "${LOG[LOGLEVEL]}" -ge "${LOG[${level}]}" ]]
}

function log.debug() {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | while read -r line ; do
        log.log "[DEBUG] $line"
    done
}

function log.dryrun() {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | while read -r line ; do
        log.log "[DRYRUN] $line"
    done
}

function log.error() {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | while read -r line ; do
        log.log "[ERROR] $line"
    done 1>&2
}

function log.fatal() {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | while read -r line ; do
        log.log "[FATAL] $line"
    done 1>&2
    gqc.exit_1
}

function log.info() {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | while read -r line ; do
        log.log "[INFO] $line"
    done
}

function log.log() {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | tee >(log.log-to-logfile "$@") | while read -r line ; do
        if log.should-log "${FUNCNAME[1]}"; then
            echo "${line}"
        fi
    done
}

function log.log-to-logfile() {
    if [[ -n "${LOG[LOGFILE]:-}" ]]; then
        [[ ( -f "${LOG[LOGFILE]}" ) && ( -w "${LOG[LOGFILE]}" ) ]] ||
            (local d; d=$(dirname -- "${LOG[LOGFILE]}"); mkdir -p "${d}" && touch -- "${LOG[LOGFILE]}")
        local rid=
        [[ "${LOG[USE_TIMESTAMP]}" == 'true' ]] && rid="$(date +%Y%m%dT%H%M%S) ${rid}"
        [[ -n "${LOG[REQUESTID]}" ]] && rid="${LOG[REQUESTID]} ${rid} "
        if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | while read -r line ; do
            echo "${rid}${line}" >> "${LOG[LOGFILE]}"
        done
    fi
}

function log.warn() {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | while read -r line ; do
        log.log "[WARN] $line"
    done
}

function text.canonicalize() {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | \
        perl -MUnicode::Normalize -lane '
            use open qw(:std :utf8);
            my $s = NFKD(qq($_));
            $s =~ s/[^[:alpha:]]//g;
            $s = lc($s);
            $s =~ s/^[[:space:]]+|[[:space:]]$//g;
            $s =~ s/[[:space:]]+//g;
            print qq($s);
       '
}

function text.clean() {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | \
        text.trim
}

function text.trim() {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | \
        tr -d '\015' | \
        sed 's/^[[:space:]]+//' | \
        sed 's/[[:space:]]+$//'
}

function util.readlink_e() {
    local TARGET_FILE=$1
    local dir
    dir=$(dirname "${TARGET_FILE}")
    cd "${dir}"
    TARGET_FILE=$(basename "${TARGET_FILE}")
    # Iterate down a (possible) chain of symlinks
    while [[ -L "${TARGET_FILE}" ]]; do
        TARGET_FILE=$(readlink "${TARGET_FILE}")
        dir=$(dirname "${TARGET_FILE}")
        cd "${dir}"
        TARGET_FILE=$(basename "${TARGET_FILE}")
    done
    # Compute the canonicalized name by finding the physical path 
    # for the directory we're in and appending the target file.
    local PHYS_DIR
    PHYS_DIR=$(pwd -P)
    echo "${PHYS_DIR}/${TARGET_FILE}"
}

function gqc.initialize() {
    local command prg task taskdir tmpdir
    prg=$(readlink -e "$0")
    [[ ( -n "${prg}" ) && ( -f "${prg}" ) ]] || (echo "[FATAL] Cannot locate: '$0'" 1>&2; gqc.exit_1)
    task=$(basename -- "$0")
    task=${task%%.sh}
    taskdir=$(dirname -- "$0")
    taskdir=$(cd "${taskdir}" > /dev/null && pwd)
    tmpdir=$(mktemp --tmpdir --directory "org.selby.botany.gqc-XXXXXXXX")
    command="${taskdir}/${task} ${*}"

    GQC[COMMAND]="${command}"
    GQC[PRG]="${prg}"
    GQC[TASK]="${task}"
    GQC[TASKDIR]="${taskdir}"
    GQC[TMPDIR]="${tmpdir}"
    export GQC_TMPDIR="${GQC[TMPDIR]}"
    GQC[REQUESTID]=$(echo "${GQC[TASK]}+$(hostname -f)+$$+$(date -u '+%Y%m%dT%I%M%S')" | hash.sha1 | awk '{ print $1 }')
    GQC[CACHEDIR]=${GQC[CACHEDIR]:-/var/cache/selby/${GQC[TASK]}}

    LOG[LOGFILE]=${LOG[LOGFILE]:-/var/log/selby/${GQC[TASK]}/$(date '+%Y%m%dT%I%M%S').log}
}

function gqc.clean-latitude () {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | text.trim | \
        perl -ne 'chop; $_ =~ /^([+-]?\d{1,3}\.\d+)$/; printf("%.'"${GQC[LATITUDE_PRECISION]}"'f", $1);'
}

function gqc.clean-longitude () {
    if [[ -n ${1+x} ]]; then echo "$@"; else cat -; fi | text.trim | \
        perl -ne 'chop; $_ =~ /^([+-]?\d{1,3}\.\d+)$/; printf("%.'"${GQC[LONGITUDE_PRECISION]}"'f", $1);'
}

function gqc.cleanup() {
    local status=${1:-${?}}
    [[ ( -n "${GQC_TMPDIR}" ) && ( -d "${GQC_TMPDIR}" ) ]] && rm -rf "${GQC_TMPDIR}"
    exit "${status}"
}

gqc.copyright() {
    cat <<END_OF_COPYRIGHT
Geolocation Quality Control (gqc)

Copyright (C) 2020 Marie Selby Botanical Gardens

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
END_OF_COPYRIGHT
}

function gqc.exit_0 () {
    kill -USR1 $GQC_PID
    exit 0
}

function gqc.exit_1 () {
    kill -USR2 $GQC_PID
    exit 1
}

function gqc.get-options() {
    if ! options=$(getopt -n "${GQC[TASK]}" -o 'C:Hi:L:l:o:qSs:' -l 'api-host:,api-token:,cache-directory:,copyright,help,input:,latitude-precision:,log-file:,log-level:,longitude-precision:,output:,quiet,separator:,start-record:,summarize,Xdebug,Xdev' -- "$@"); then
        # something went wrong, getopt will put out an error message for us
        echo 1>&2; gqc.usage 1>&2; gqc.exit_1
    fi
    eval set -- "${options}"
    while [[ "${#}" -gt "0" ]]; do
        case ${1} in
        --api-host)
            LOCATIONIQ[API_HOST]="${2}" && shift
            ;;
        --api-token)
            LOCATIONIQ[API_TOKEN]="${2}" && shift
            ;;
        -C|--cache-directory)
            local file="${2}" && shift
            [[ ( -e "${file}" ) && ( -w "${file}") ]] || log.fatal "cache directory can not be written: '${file}'"
            GQC[CACHEDIR]="${file}"
            ;;
        --copyright)
            gqc.copyright; gqc.exit_0
            ;;
        -H|--help)
            gqc.usage; gqc.exit_0
            ;;
        -i|--input)
            GQC[INPUT]="${2}" && shift
            [[ -r "${GQC[INPUT]}" ]] || (log.fatal "file can not be read: '${GQC[INPUT]}'")
            ;;
        --latitude-precision)
            local p="${2}" && shift
            (echo "${p}" | grep -E -q '^\d+$') || (log.fatal "invalid latitude-precision: expecting positive integer - '${p}'")
            GQC[LATITUDE_PRECISION]=${p}
            ;;
        -L|--log-file)
            local file="${2}" && shift
            [[ -e "${file}" ]] || (touch -- "${file}" || log.fatal "log file can not be written: '${file}'")
            [[ -w "${file}" ]] || (chmod +w -- "${file}" || log.fatal "log file can not be written: '${file}'")
            LOG[LOGFILE]="${file}"
            ;;
        -l|--log-level)
            local level="${2}" && shift
            local l=${level^^}
            (echo "${l}" | grep -E -q '^(DEBUG|ERROR|INFO|QUIET|WARN)$') || (log.fatal "invalid log level: expecting on of DEBUG, ERROR, INFO, QUIET or WARN - '${level}'")
            LOG[LOGLEVEL]="${LOG[${l}]}"
            ;;
        --longitude-precision)
            local p="${2}" && shift
            (echo "${p}" | grep -E -q '^\d+$') || (log.fatal "invalid latitude-precision: expecting positive integer - '${p}'")
            GQC[LONGITUDE_PRECISION]=${p}
            ;;
        -o|--output)
            GQC[OUTPUT]="${2}" && shift
            [[ -w "${GQC[OUTPUT]}" ]] || (log.fatal "file can not be written: '${GQC[OUTPUT]}'")
            ;;
        -q|--quiet)
            GQC[QUIET]=true
            ;;
        -s|--separator)
            GQC[SEPARATOR]="${2}" && shift
            [[ ${#GQC[SEPARATOR]} -eq 1 ]] || (log.fatal "illegal separator '${GQC[SEPARATOR]}': expecting one character")
            ;;
        -S|--summarize)
            gqc.summarize-logfile /dev/stdin
            gqc.exit_0
            ;;
        --Xdebug)
            set -xv
            export GQC_XDEBUG=true
            export GQC_DEBUG=true
            ;;
        --Xdev)
            export GQC_XDEV=true
            export GQC_DEV=true
            ;;
        (--) shift; break
            ;;
        (-*) log.fatal "unrecognized option ${1}" 1>&2; gqc.usage
            ;;
        (*) break
            ;;
        esac
        shift
    done
    shift $((OPTIND-1))
}

function gqc.main() {
    [[ "${GQC_DEBUG}" == 'true' ]] && echo "gqc.main: ${*}"
    gqc.initialize "${@}"
    gqc.get-options "${@}"
    log.debug "gqc.main: ${*}"
    log.debug "GQC[PRG]=${GQC[PRG]}"
    log.debug "GQC[TASK]=${GQC[TASK]}"
    log.debug "GQC[TASKDIR]=${GQC[TASKDIR]}"
    log.debug "GQC[COMMAND]=${GQC[COMMAND]}"
    log.debug "GQC[REQUESTID]=${GQC[REQUESTID]}"
    log.debug "GQC[CACHEDIR]=${GQC[CACHEDIR]}"
    log.debug "GQC[INPUT]=${GQC[INPUT]}"
    log.debug "GQC[LATITUDE_PRECISION]=${GQC[LATITUDE_PRECISION]}"
    log.debug "GQC[LONGITUDE_PRECISION]=${GQC[LONGITUDE_PRECISION]}"
    log.debug "GQC[OUTPUT]=${GQC[OUTPUT]}"
    log.debug "GQC[QUIET]=${GQC[QUIET]}"
    log.debug "GQC[SEPARATOR]=${GQC[SEPARATOR]}"
    log.debug "GQC[DEBUG]=${GQC[DEBUG]}"
    log.debug "GQC[DEV]=${GQC[DEV]}"
    log.debug "LOG[LOGFILE]=${LOG[LOGFILE]}"
    log.debug "LOG[LOGLEVEL]=${LOG[LOGLEVEL]}"
    log.debug "LOCATIONIQ[API_TOKEN]=${LOCATIONIQ[API_TOKEN]}"
    log.debug "LOCATIONIQ[API_HOST]=${LOCATIONIQ[API_HOST]}"

    [[ -n $(gqc.reverse-geolocate 0 0 false) ]] ||
        log.fatal "LocationIQ API unreachable: token ${LOCATIONIQ[API_TOKEN]}, host ${LOCATIONIQ[API_HOST]}"

    local n=0
    local OLDIFS="${IFS}"
    IFS="${GQC[SEPARATOR]}"
    local country state selbyNumber latitude longitude

    text.trim <"${GQC[INPUT]}" | while read -r country state selbyNumber latitude longitude ; do
        log.debug "raw-record: country='${country}' state='${state}' selbyNumber='${selbyNumber}' latitude='${latitude}' longitude='${longitude}'"
        (echo "${country}" | text.trim | grep -q -E '^\s*#') && continue # Skip comment lines
        (echo "${selbyNumber}" | grep -q -E -v '^[[:digit:]]+$') && continue # Skip if selbyNumber is not a decimal number
        if [[ ( -z "${latitude}" ) || ( -z "${longitude}" ) ]]; then
            log.error "SN-${selbyNumber}: unable to reverse geolocate; missing latitude or longitude"
        else
            local c_country c_state c_latitude c_longitude response
            c_country=$(text.canonicalize "${country}")
            c_state=$(text.canonicalize "${state}")
            c_latitude=$(gqc.clean-latitude "${latitude}")
            c_longitude=$(gqc.clean-latitude "${longitude}")
            log.debug "cleaned: c_country='${c_country}' c_state='${c_state}' selbyNumber='${selbyNumber}' c_latitude='${c_latitude}' c_longitude='${c_longitude}'"
            response=$(gqc.reverse-geolocate "${c_latitude}" "${c_longitude}")
            log.debug "[lat='${c_latitude}', lon='${c_longitude}'] => '${response}'"
            if [[ -z "${response}" ]]; then
                log.error "SN-${selbyNumber}: reverse geolocate failed [lat='${c_latitude}', lon='${c_longitude}']"
            else
                local r_city r_country  r_country_code r_county r_display_name r_region r_state
                r_city=$(echo "${response}" | jq .address.city | tr -d '"')
                r_country=$(echo "${response}" | jq .address.country | tr -d '"')
                r_country_code=$(echo "${response}" | jq .address.country_code | tr -d '"')
                r_county=$(echo "${response}" | jq .address.county | tr -d '"')
                r_display_name=$(echo "${response}" | jq .display_name | tr -d '"')
                r_region=$(echo "${response}" | jq .address.region | tr -d '"')
                r_state=$(echo "${response}" | jq .address.state | tr -d '"')
                local c_r_city c_r_country c_r_country_code c_r_county c_r_region c_r_state
                c_r_city=$(text.canonicalize "${r_city}")
                c_r_country=$(text.canonicalize "${r_country}")
                c_r_country_code=$(text.canonicalize "${r_country_code}")
                c_r_county=$(text.canonicalize "${r_county}")
                c_r_state=$(text.canonicalize "${r_state}")
                c_r_region=$(text.canonicalize "${r_region}")
                log.debug "reverse-geocode: {sn=$selbyNumber, country=\"${c_country}\", div1=\"${c_state}\", lat=${c_latitude}, lon=${c_longitude}} => {country=\"${r_country}\", canonical_country=\"${c_r_country}\", country_code=\"${r_country_code}\", canonical_country_code=\"${c_r_country_code}\", state=\"${r_state}\", canonical_state=\"${c_r_state}\", county=\"${r_county}\", canonical_county=\"${c_r_county}\", city=\"${r_city}\", canonical_city=\"${c_r_city}\", region=\"${r_region}\", canonical_region=\"${c_r_region}\", display_name=\"${r_display_name}\", response=${response}}}"
                if [[ "${c_r_country}" != "${c_country}" ]]; then
                    log.error "SN-${selbyNumber}: country '${country}' != reverse geocode '${r_country}'"
                fi
                if [[ "${c_r_state}" != "${c_state}" ]]; then
                    log.error "SN-${selbyNumber}: div1 '${state}' != reverse geocode '${r_state}'"
                fi
            fi
        fi

        # TODO - Add a start and end record number to process; syntactic sugar for piping the dataset through head and tail.
        n=$((n+1))
        if false; then if [[ "${n}" -gt 1 ]]; then gqc.exit_0; fi fi
    done
    IFS="${OLDIFS}"
    gqc.summarize-logfile
}

function gqc.reverse-geolocate() {
    local latitude longitude
    latitude=$(text.trim "${1:?Need latitude}")
    longitude=$(text.trim "${2:?Need longitude}")
    local usecache="${3:-true}"
    local cachekey="latitude:${latitude},longitude:${longitude}"
    if [[ "${usecache}" == 'true' ]] && cache.exists "${cachekey}"; then
        cache.get "${cachekey}"
    else
        result=$(locationiq.reverse-geolocate "${latitude}" "${longitude}")
        [[ ( -n "${result}" ) && ( "${usecache}" == 'true' ) ]] && cache.put "${cachekey}" "${result}"
        echo "${result}"
    fi
}

function gqc.summarize-logfile() {
    local logfile=${1:-${LOG[LOGFILE]}}
    [[ -r "${logfile}" ]] && log.info "Summary" && 
        ("${GQC[TASKDIR]}/gqc-summarize" <"${logfile}" | log.info)
    true
}

function gqc.usage() {
    cat <<END_OF_USAGE
Usage: ${GQC[TASK]} [OPTION]...

Performs a georeferencing quality control check. The input file is in
CSV (comma separated values), but a different field separator can be
specified with the --separator option.

Input is read from /dev/stdin unless the --input option is given.

Output is to /dev/stdout unless the --output option is given.

      --api-token              LocationIQ API token
      --api-host               LocationIQ API endpoint hostname
  -C, --cache-directory d      Cache directory; defaults to "/var/cache/selby/gqc"
      --comment-character c    All input records starting at any amount of
                               whitespace followed by the comment character will
                               be ignored; defaults character if '#'.
      --container-name n       Override the docker container name
      --copyright              Display the copyright and exit
  -H, --help                   Display this help and exit
      --latitude-precision p   Number of fractional digits of precision in latitude;
                               defaults to 3
  -L, --log-file file          The log file; defaults to "/var/log/selby/gqc/{timestamp}.log"
  -l, --log-level              Sets the lowest severity level of log messages to show;
                               one of DEBUG, INFO, WARN, ERROR, or QUIET; defaults to FATAL
      --longitude-precision p  Number of fractional digits of precision in
                               longitude; defaults to 3
  -n, --name n                 Synonym for "--container-name n"
      --no-build               Do not build the gqc image if it is missing
      --no-pull                Do not pull the gqc image if it is available on DockerHub
  -s, --separator s            Field separator; defaults to ","
  -S. --summarize              Summarize a log file piped to stdin and exit
      --Xdebug                 Enable execution tracing
      --Xdev                   Enable developer mode; mounts "src" and "data"
      --Xbuild-arguments args  String of arguments to add to docker invocation.
      --Xrun-command cmd       Container command to invoke on docker invocation
      --Xdryrun                Display the docker command to be run and exit
      --Xmount                 Additional docker mount specification (implies "--Xdev")
      --Xrepository            The image repository name to load
      --Xtag                   The image tag to load
      --                       Terminates the list of options


The --api-token and --api-host options get their default values from
configuration variables, LOCATIONIQ_API_HOST and LOCATIONIQ_API_TOKEN,
respectively. Configuration variable are searched for in ~/.gqc,
/usr/local/selby/config/gqc.init, and INSTALLDIR/src/config/gqc.ini, in that
order. See INSTALLDIR/src/config/gqc.ini as an example.

The --latitude-precision and --longitude-precision values specify the precision
of the location's coordinates, and hence specify the "resolution" of the location;
i.e. how many fractional decimal digits are used to identify a geolocation. More
digits means a finer resolution. Coordinates that are equal, after rounding to
the specified number of fractional digits, are considered to be the same location.
Near the equator the approximate resolution corresponding to different precisions:
    
    5 digits is ~1 meter resolution
    4 digits is ~10 meter resolution
    3 digits is ~100 meter resolution
    2 digits is ~1 kilometer resolution
    1 digits is ~10 kilometer resolution


All options starting with -X are for testing only. Only use them if you know what
you are doing.
END_OF_USAGE
}

trap 'gqc.cleanup 0' USR1
trap 'gqc.cleanup 1' USR2 HUP INT TERM
# trap 'gqc.cleanup' EXIT
(
    gqc.main "$@"
)
trap - HUP INT TERM EXIT USR1 USR2
exit 0
